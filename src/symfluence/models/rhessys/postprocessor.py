"""
RHESSys Model Postprocessor

Handles output extraction, processing, and analysis for RHESSys model outputs.
"""
import logging
from pathlib import Path
from typing import Dict, Any, Optional

import pandas as pd
import numpy as np

from symfluence.models.registry import ModelRegistry
from symfluence.models.base import BaseModelPostProcessor

logger = logging.getLogger(__name__)


@ModelRegistry.register_postprocessor('RHESSys')
class RHESSysPostProcessor(BaseModelPostProcessor):
    """
    Postprocessor for RHESSys model outputs within SYMFLUENCE.

    Handles output extraction, processing, and analysis.
    Inherits common functionality from BaseModelPostProcessor.

    RHESSys outputs include:
    - Basin daily files (*_basin.daily): Basin-averaged water balance
    - Patch daily files (*_patch.daily): Patch-level outputs
    - Hillslope daily files (*_hillslope.daily): Hillslope-level outputs
    - Growth output files (*_grow_*.daily): Carbon/nitrogen cycling

    The primary output variable is streamflow (discharge) from the basin daily file.
    """

    def _get_model_name(self) -> str:
        """Return model name for RHESSys."""
        return "RHESSys"

    def _setup_model_specific_paths(self) -> None:
        """Setup RHESSys-specific paths."""
        self.rhessys_output_dir = self.sim_dir

    def extract_results(self) -> Dict[str, Path]:
        """
        Extract and process all RHESSys results.

        Returns:
            Dict[str, Path]: Paths to processed result files
        """
        self.logger.info("Extracting RHESSys results")

        results = {}
        try:
            # Process streamflow
            streamflow_path = self.extract_streamflow()
            if streamflow_path:
                results['streamflow'] = streamflow_path
                self.logger.info("Streamflow extracted successfully")

        except Exception as e:
            self.logger.error(f"Error extracting RHESSys results: {str(e)}")
            import traceback
            self.logger.error(traceback.format_exc())
            raise

        return results

    def extract_streamflow(self) -> Optional[Path]:
        """
        Extract simulated streamflow from RHESSys output and save to CSV.

        Reads from:
        1. rhessys_results.csv (if generated by runner)
        2. rhessys_basin.daily (standard RHESSys output)

        Returns:
            Optional[Path]: Path to the saved CSV file if successful, None otherwise
        """
        try:
            self.logger.info("Processing RHESSys streamflow results")

            # First try the pre-generated results CSV
            results_csv = self.sim_dir / "rhessys_results.csv"
            if results_csv.exists():
                self.logger.info(f"Reading from results CSV: {results_csv}")
                df = pd.read_csv(results_csv, index_col=0, parse_dates=True)
                if 'streamflow_cms' in df.columns:
                    q_sim = df['streamflow_cms']
                    return self.save_streamflow_to_results(
                        q_sim,
                        model_column_name='RHESSys_discharge_cms'
                    )

            # Try standard RHESSys basin daily output
            basin_daily = self.sim_dir / "rhessys_basin.daily"
            if basin_daily.exists():
                self.logger.info(f"Reading from basin daily file: {basin_daily}")
                q_sim = self._read_basin_daily(basin_daily)
                if q_sim is not None:
                    return self.save_streamflow_to_results(
                        q_sim,
                        model_column_name='RHESSys_discharge_cms'
                    )

            # Try any basin daily file
            basin_files = list(self.sim_dir.glob("*_basin.daily"))
            if basin_files:
                self.logger.info(f"Reading from: {basin_files[0]}")
                q_sim = self._read_basin_daily(basin_files[0])
                if q_sim is not None:
                    return self.save_streamflow_to_results(
                        q_sim,
                        model_column_name='RHESSys_discharge_cms'
                    )

            self.logger.error(f"No RHESSys output files found in {self.sim_dir}")
            return None

        except Exception as e:
            self.logger.error(f"Error extracting streamflow: {str(e)}")
            import traceback
            self.logger.error(traceback.format_exc())
            return None

    def _get_basin_area_m2(self) -> float:
        """
        Get total basin area in m² from shapefile.

        Returns:
            Basin area in square meters
        """
        try:
            import geopandas as gpd

            # Try to find HRU shapefile
            catchment_dir = self.config.data_directory / "shapefiles" / "catchment"
            domain_name = self.config.domain_config.domain_name

            # Try different shapefile naming conventions
            shp_patterns = [
                f"{domain_name}_HRUs_GRUs.shp",
                f"{domain_name}_HRUs.shp",
                f"{domain_name}_catchment.shp",
                "*.shp"
            ]

            shp_path = None
            for pattern in shp_patterns:
                matches = list(catchment_dir.glob(pattern))
                if matches:
                    shp_path = matches[0]
                    break

            if shp_path is None:
                self.logger.warning("No catchment shapefile found, using default area")
                return 2.2e9  # Default ~2200 km²

            gdf = gpd.read_file(shp_path)

            # Reproject to UTM for accurate area calculation
            if gdf.crs and gdf.crs.is_geographic:
                gdf_proj = gdf.to_crs(gdf.estimate_utm_crs())
                total_area_m2 = gdf_proj.geometry.area.sum()
            else:
                total_area_m2 = gdf.geometry.area.sum()

            self.logger.info(f"Basin area: {total_area_m2/1e6:.2f} km²")
            return total_area_m2

        except Exception as e:
            self.logger.warning(f"Could not calculate basin area: {e}, using default")
            return 2.2e9  # Default ~2200 km²

    def _read_basin_daily(self, filepath: Path) -> Optional[pd.Series]:
        """
        Read RHESSys basin daily output file.

        RHESSys outputs streamflow in mm/day (depth over the basin).
        This method converts to m³/s using the basin area.

        Conversion: Q (m³/s) = Q (mm/day) × basin_area (m²) / (1000 × 86400)

        Args:
            filepath: Path to basin daily file

        Returns:
            Pandas Series of streamflow (cms) indexed by date
        """
        try:
            # RHESSys basin daily format varies, try different approaches
            df = pd.read_csv(filepath, sep=r'\s+', comment='#')

            # Construct date from year/month/day columns
            if all(col in df.columns for col in ['year', 'month', 'day']):
                df['date'] = pd.to_datetime(df[['year', 'month', 'day']])
                df.set_index('date', inplace=True)
            elif 'DATE' in df.columns:
                df['date'] = pd.to_datetime(df['DATE'])
                df.set_index('date', inplace=True)

            # Find streamflow column
            q_col = None
            for col in ['streamflow', 'Qout', 'discharge', 'streamflow_m3s', 'Q']:
                if col in df.columns:
                    q_col = col
                    break

            if q_col is None:
                # Look for any column containing 'stream' or 'flow'
                for col in df.columns:
                    if 'stream' in col.lower() or 'flow' in col.lower() or col.lower() == 'q':
                        q_col = col
                        break

            if q_col is None:
                self.logger.error(f"No streamflow column found in {filepath}")
                self.logger.info(f"Available columns: {list(df.columns)}")
                return None

            q_mm_day = df[q_col]

            self.logger.info(f"Raw streamflow from column '{q_col}' (mm/day): "
                           f"mean={q_mm_day.mean():.4f}, min={q_mm_day.min():.4f}, max={q_mm_day.max():.4f}")

            # Convert mm/day to m³/s
            # Q (m³/s) = Q (mm/day) × basin_area (m²) / (1000 mm/m × 86400 s/day)
            basin_area_m2 = self._get_basin_area_m2()
            conversion_factor = basin_area_m2 / (1000.0 * 86400.0)

            q_cms = q_mm_day * conversion_factor

            self.logger.info(f"Converted streamflow (m³/s): "
                           f"mean={q_cms.mean():.4f}, min={q_cms.min():.4f}, max={q_cms.max():.4f}")
            self.logger.info(f"Conversion factor: {conversion_factor:.6f} (basin area: {basin_area_m2/1e6:.2f} km²)")

            return q_cms

        except Exception as e:
            self.logger.error(f"Error reading basin daily file: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            return None

    def extract_water_balance(self) -> Optional[pd.DataFrame]:
        """
        Extract full water balance from RHESSys output.

        Returns:
            DataFrame with water balance components (P, ET, Q, storage change)
        """
        try:
            basin_files = list(self.sim_dir.glob("*_basin.daily"))
            if not basin_files:
                return None

            df = pd.read_csv(basin_files[0], sep=r'\s+')

            # Construct date
            if all(col in df.columns for col in ['year', 'month', 'day']):
                df['date'] = pd.to_datetime(df[['year', 'month', 'day']])
                df.set_index('date', inplace=True)

            # Extract available water balance components
            wb_cols = {}
            col_mapping = {
                'precip': ['precip', 'rain', 'precipitation', 'P'],
                'evap': ['evap', 'evaporation', 'ET', 'aet'],
                'trans': ['trans', 'transpiration'],
                'streamflow': ['streamflow', 'Qout', 'discharge', 'Q'],
                'baseflow': ['baseflow', 'Qbase', 'gw_Qout'],
                'snow': ['snowpack', 'swe', 'snow_water_equiv'],
            }

            for comp, candidates in col_mapping.items():
                for cand in candidates:
                    if cand in df.columns:
                        wb_cols[comp] = df[cand]
                        break

            if wb_cols:
                return pd.DataFrame(wb_cols)
            return None

        except Exception as e:
            self.logger.error(f"Error extracting water balance: {e}")
            return None
