# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2024-2026 SYMFLUENCE Team <dev@symfluence.org>

"""
SWAT Routing and Control File Generator

Generates the master control file (file.cio), watershed routing file (fig.fig),
reach routing files (.rte, .swq), and database stub files for SWAT.
"""
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class SWATRoutingGenerator:
    """Generates routing, control, and database files for SWAT.

    Args:
        preprocessor: Parent SWATPreProcessor instance providing access
            to config, logger, paths, and helper methods.
    """

    def __init__(self, preprocessor):
        self.pp = preprocessor

    def generate_file_cio(self, start_date: datetime, end_date: datetime) -> None:
        """Generate SWAT master control file (file.cio).

        The file.cio is read line-by-line by SWAT's getallo.f and readfile.f
        routines. Each line must be in exactly the right position. Values use
        the first 16 columns (right-justified numbers or left-justified
        filenames) followed by '| VARNAME : description'.

        Filenames are read with Fortran format (6a) which reads the first
        ~13 characters. Numeric values are read with list-directed I/O
        (read *) which extracts the first valid number from the line.
        """
        warmup_years = self.pp._get_config_value(
            lambda: self.pp.config.model.swat.warmup_years,
            default=2
        )

        nbyr = end_date.year - start_date.year + 1
        iyr = start_date.year
        idaf = start_date.timetuple().tm_yday
        idal = end_date.timetuple().tm_yday

        # Helper: format a filename value line (left-justified, 13 chars).
        # Fortran format (6a) reads first 13 chars as the filename.
        def fline(fname, comment):
            return f"{fname:13s} | {comment}"

        # Helper: format an integer value line (right-justified, 16 chars).
        # Fortran list-directed read (*) extracts the first valid number.
        def iline(val, comment):
            return f"{val:16d}    | {comment}"

        # Helper: format a float value line (right-justified, 16 chars).
        def rline(val, comment):
            return f"{val:16.3f}    | {comment}"

        # Helper: format a gage file array line.
        # Fortran format (6a) with character(len=13) reads 6 filenames
        # of 13 chars each per record.  For 18 filenames that is 3 lines.
        def gage_file_lines(filenames):
            """Return 3 lines of 6 x 13-char filename slots (total 18)."""
            padded = list(filenames) + [''] * (18 - len(filenames))
            result = []
            for row in range(3):
                parts = padded[row * 6:(row + 1) * 6]
                result.append(''.join(f"{p:13s}" for p in parts))
            return result

        cio_path = self.pp.txtinout_dir / 'file.cio'

        # ----------------------------------------------------------------
        # Build file.cio line by line matching readfile.f / getallo.f read
        # order.  Line numbers (FL) are the sequential file-line positions
        # consumed by both Fortran routines reading the same file.
        #
        # CRITICAL: readfile.f reads rfile(1:18) and tfile(1:18) with
        # Fortran format (6a).  With character(len=13) variables and 18
        # items, this consumes 3 records (lines) per array -- 6 filenames
        # of 13 chars each per line.  getallo.f simply skips all these
        # lines with read(23,6000) titldum, so the line count must match.
        # ----------------------------------------------------------------
        lines = []

        # --- Title lines (FL 1-5) ---
        # Both getallo.f and readfile.f use `use parm` where
        # title is declared as character(len=4) :: title(60).
        # Format 5100 = (20a4) reads 20 items per record, so
        # 60 items = 3 records (lines).  Both routines read:
        #   read(unit,6000/5101) titldum   -> FL 1
        #   read(unit,6000/5101) titldum   -> FL 2
        #   read(unit,5100) title          -> FL 3, FL 4, FL 5
        lines.append(" Master watershed file: file.cio")                     # FL 1
        lines.append(" SYMFLUENCE auto-generated SWAT input")               # FL 2
        lines.append(" Simulation generated by SYMFLUENCE preprocessor")    # FL 3
        lines.append("")                                                     # FL 4
        lines.append("")                                                     # FL 5

        # --- General Information (FL 6-11) ---
        lines.append(" General Information/Watershed Configuration:")        # FL 6
        lines.append(fline("fig.fig", "FIGFILE"))                           # FL 7
        lines.append(iline(nbyr, "NBYR : Number of years simulated"))       # FL 8
        lines.append(iline(iyr, "IYR : Beginning year of simulation"))      # FL 9
        lines.append(iline(idaf, "IDAF : Beginning julian day"))            # FL 10
        lines.append(iline(idal, "IDAL : Ending julian day"))               # FL 11

        # --- Climate (FL 12-33) ---
        lines.append(" Climate:")                                            # FL 12
        lines.append(iline(0, "IGEN : Random generator seed"))              # FL 13
        lines.append(iline(1, "PCPSIM : Precip input (1=measured)"))        # FL 14
        lines.append(iline(0, "IDT : Sub-daily timestep (0=daily)"))        # FL 15
        lines.append(iline(0, "IDIST : Rainfall distribution code"))        # FL 16
        lines.append(rline(0.0, "REXP : Mixed exponential exponent"))       # FL 17
        lines.append(iline(1, "NRGAGE : Number of precip gage files"))      # FL 18
        lines.append(iline(1, "NRTOT : Total number of precip gages"))      # FL 19
        lines.append(iline(1, "NRGFIL : Precip gages per file"))            # FL 20
        lines.append(iline(1, "TMPSIM : Temp input (1=measured)"))          # FL 21
        lines.append(iline(1, "NTGAGE : Number of temp gage files"))        # FL 22
        lines.append(iline(1, "NTTOT : Total number of temp gages"))        # FL 23
        lines.append(iline(1, "NTGFIL : Temp gages per file"))              # FL 24
        lines.append(iline(2, "SLRSIM : Solar rad (2=simulated)"))          # FL 25
        lines.append(iline(0, "NSTOT : Number of solar rad records"))       # FL 26
        lines.append(iline(2, "RHSIM : Rel humidity (2=simulated)"))        # FL 27
        lines.append(iline(0, "NHTOT : Number of humidity records"))        # FL 28
        lines.append(iline(2, "WNDSIM : Wind speed (2=simulated)"))         # FL 29
        lines.append(iline(0, "NWTOT : Number of wind speed records"))      # FL 30
        lines.append(iline(0, "FCSTYR : Forecast begin year (0=off)"))      # FL 31
        lines.append(iline(0, "FCSTDAY : Forecast begin julian day"))       # FL 32
        lines.append(iline(0, "FCSTCYCLES : Forecast cycles"))              # FL 33

        # --- Precipitation Input Files (FL 34-37) ---
        lines.append(" Precipitation Input Files:")                          # FL 34
        lines.extend(gage_file_lines(["pcp1.pcp"]))                         # FL 35-37

        # --- Temperature Input Files (FL 38-41) ---
        lines.append(" Temperature Input Files:")                            # FL 38
        lines.extend(gage_file_lines(["tmp1.tmp"]))                         # FL 39-41

        # --- Solar / Humidity / Wind / Forecast files (FL 42-45) ---
        lines.append(fline("", "SLRFILE : Solar radiation file"))           # FL 42
        lines.append(fline("", "RHFILE : Relative humidity file"))          # FL 43
        lines.append(fline("", "WNDFILE : Wind speed file"))               # FL 44
        lines.append(fline("", "FCSTFILE : Weather forecast file"))         # FL 45

        # --- Watershed Modeling Options (FL 46-47) ---
        lines.append(" Watershed Modeling Options:")                         # FL 46
        lines.append(fline("basins.bsn", "BSNFILE : Basin input file"))    # FL 47

        # --- Database Files (FL 48-53) ---
        lines.append(" Database Files:")                                     # FL 48
        lines.append(fline("plant.dat", "PLANTDB : Plant database"))        # FL 49
        lines.append(fline("till.dat", "TILLDB : Tillage database"))        # FL 50
        lines.append(fline("pest.dat", "PESTDB : Pesticide database"))      # FL 51
        lines.append(fline("fert.dat", "FERTDB : Fertilizer database"))     # FL 52
        lines.append(fline("urban.dat", "URBANDB : Urban database"))        # FL 53

        # --- Special Projects (FL 54-57) ---
        lines.append(" Special Projects:")                                   # FL 54
        lines.append(iline(0, "ISPROJ : Special project code"))             # FL 55
        lines.append(iline(0, "ICLB : Auto-calibration flag"))             # FL 56
        lines.append(fline("", "CALFILE : Calibration input file"))         # FL 57

        # --- Output Information (FL 58-63) ---
        lines.append(" Output Information:")                                 # FL 58
        lines.append(iline(1, "IPRINT : Output (0=mon,1=day,2=yr)"))       # FL 59
        lines.append(iline(warmup_years, "NYSKIP : Years to skip"))         # FL 60
        lines.append(iline(0, "ILOG : Streamflow output code"))             # FL 61
        lines.append(iline(0, "IPRP : Pesticide output code"))             # FL 62
        lines.append(" Reach (output.rch) print-frequency option:")          # FL 63

        # --- Output Variable Selection (FL 64-71) ---
        lines.append(" Reach output variables:")                             # FL 64
        lines.append(" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")          # FL 65
        lines.append(" Subbasin output variables:")                          # FL 66
        lines.append(" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")                     # FL 67
        lines.append(" HRU output variables:")                               # FL 68
        lines.append(" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")          # FL 69
        lines.append(" HRU printout selection:")                             # FL 70
        lines.append(" 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")          # FL 71

        # --- Atmospheric Deposition (FL 72-73) ---
        lines.append(" Atmospheric deposition:")                             # FL 72
        lines.append(fline("", "ATMOFILE : Atmospheric deposition"))        # FL 73

        # --- Additional optional outputs (FL 74-77) ---
        lines.append(iline(0, "IPHR : Hourly output (0=off)"))              # FL 74
        lines.append(iline(0, "ISTO : Soil storage output (0=off)"))        # FL 75
        lines.append(iline(0, "ISOL : Soil nutrient output (0=off)"))       # FL 76
        lines.append(iline(0, "I_SUBHW : Headwater routing (0=off)"))       # FL 77

        # --- Septic Database (FL 78) ---
        lines.append(fline("", "SEPTDB : Septic database file"))            # FL 78

        # --- Binary output flag (FL 79) ---
        lines.append(iline(0, "IA_B : ASCII(0) or Binary(1) output"))       # FL 79

        # --- Additional optional flags (FL 80+) ---
        lines.append(iline(0, "IHUMUS : Water quality output (0=off)"))     # FL 80
        lines.append(iline(0, "ITEMP : Velocity/depth output (0=off)"))     # FL 81
        lines.append(iline(0, "ISNOW : Snowband output (0=off)"))           # FL 82
        lines.append(iline(0, "IMGT : Management output (0=off)"))          # FL 83
        lines.append(iline(0, "IWTR : Water balance output (0=off)"))       # FL 84
        lines.append(iline(0, "ICALEN : Calendar day (0=julian)"))          # FL 85

        cio_path.write_text('\n'.join(lines) + '\n', encoding='utf-8')
        logger.info(f"Master control file written: {cio_path}")

    def generate_fig_file(self) -> None:
        """Generate SWAT watershed routing file (fig.fig).

        The fig.fig defines the routing structure. For a lumped
        (single sub-basin) model it contains:
          1. SUBBASIN command  -- loads subbasin, stores HRU output at hyd(1)
          2. ROUTE command     -- routes hyd(1) through the reach channel
          3. SAVE command      -- writes reach output (output.rch)
          4. END command       -- terminates routing
        """
        fig_path = self.pp.txtinout_dir / 'fig.fig'
        # Format: a1, 9x, 5i6 per line  (format 5001 in getallo.f)
        #   col 11-16  icd   command code
        #   col 17-22  iht   hydrograph storage location
        #   col 23-28  inm1  (varies by command)
        #   col 29-34  inm2  (varies by command)
        #   col 35-40  inm3  (varies by command)
        fmt = lambda *v: f" {'':9s}" + ''.join(f'{x:6d}' for x in v)
        lines = []
        # Format fields per readfig.f:
        #   icodes, ihouts, inum1s, inum2s, inum3s
        # 1. Subbasin: icd=1, ihouts=1(hyd loc), inum1s=1(sub#), inum2s=0, inum3s=0
        lines.append(fmt(1, 1, 1, 0, 0))
        # format 5100: 10x,2a13 -- sub filename on one line
        lines.append(f"{'':10s}{'000010001.sub':13s}")
        # 2. Route: icd=2, ihouts=2(hyd loc), inum1s=1(reach#), inum2s=1(inflow hyd), inum3s=0
        lines.append(fmt(2, 2, 1, 1, 0))
        # format 5100: 10x,2a13 -- .rte and .swq on ONE line
        lines.append(f"{'':10s}{'000010001.rte':13s}{'000010001.swq':13s}")
        # 3. Add: icd=5, ihouts=0, inum1s=2(hyd to save), inum2s=0, inum3s=0
        lines.append(fmt(5, 0, 2, 0, 0))
        # 4. End: icd=0
        lines.append(fmt(0, 0, 0, 0, 0))

        fig_path.write_text('\n'.join(lines) + '\n', encoding='utf-8')
        logger.info(f"Routing file written: {fig_path}")

    def generate_route_files(self) -> None:
        """Generate SWAT reach routing (.rte) and stream water quality (.swq) files.

        For a lumped single-reach setup, these contain default Muskingum
        routing parameters and minimal water-quality settings.
        """
        # .rte file -- reach routing parameters
        rte_path = self.pp.txtinout_dir / '000010001.rte'
        rte_lines = [
            " Reach 1 -- SYMFLUENCE generated",
            f"{'':12s}{10.000:12.3f}    | CH_W2 : Main channel width [m]",
            f"{'':12s}{2.000:12.3f}    | CH_D : Main channel depth [m]",
            f"{'':12s}{0.014:12.3f}    | CH_N2 : Manning n for channel",
            f"{'':12s}{0.000:12.3f}    | CH_K2 : Channel effective hydraulic conductivity [mm/hr]",
            f"{'':12s}{1.000:12.3f}    | CH_L2 : Main channel length [km]",
            f"{'':12s}{0.050:12.3f}    | CH_S2 : Channel slope [m/m]",
            f"{'':12s}{0.000:12.3f}    | ALPHA_BNK : Baseflow alpha factor",
            f"{'':12s}{0.000:12.3f}    | ICANAL : Irrigation canal",
            f"{'':12s}{0.000:12.3f}    | CH_COV1 : Channel cover factor",
            f"{'':12s}{0.000:12.3f}    | CH_COV2 : Channel cover factor",
            f"{'':12s}{0.000:12.3f}    | CH_WDR : Channel width/depth ratio",
            f"{'':12s}{0.000:12.3f}    | ALPHA_BNK_D : Deep baseflow alpha",
        ]
        rte_path.write_text('\n'.join(rte_lines) + '\n', encoding='utf-8')

        # .swq file -- stream water quality (minimal stub)
        swq_path = self.pp.txtinout_dir / '000010001.swq'
        swq_lines = [
            " Stream water quality -- SYMFLUENCE generated",
            f"{'':12s}{0.000:12.3f}    | RS1 : Local algae settling rate [m/day]",
            f"{'':12s}{0.050:12.3f}    | RS2 : Benthic source rate for DO [mg O2/m2 day]",
            f"{'':12s}{0.500:12.3f}    | RS3 : Benthic source rate for NH4 [mg N/m2 day]",
            f"{'':12s}{0.050:12.3f}    | RS4 : Rate coefficient for org N settling",
            f"{'':12s}{0.050:12.3f}    | RS5 : Org P settling rate",
            f"{'':12s}{0.000:12.3f}    | RS6 : Benthic source rate for P [mg P/m2 day]",
            f"{'':12s}{0.000:12.3f}    | RS7 : Benthic source rate for P [mg P/m2 day]",
            f"{'':12s}{0.000:12.3f}    | RK1 : CBOD deoxygenation rate [1/day]",
            f"{'':12s}{0.000:12.3f}    | RK2 : Reaeration rate [1/day]",
            f"{'':12s}{0.000:12.3f}    | RK3 : Settling rate for CBOD [1/day]",
            f"{'':12s}{0.000:12.3f}    | RK4 : Sediment oxygen demand [mg O2/m2 day]",
            f"{'':12s}{0.000:12.3f}    | RK5 : Organic N settling rate [1/day]",
            f"{'':12s}{0.000:12.3f}    | RK6 : Settling rate for org P [1/day]",
            f"{'':12s}{15.000:12.3f}    | BC1 : Rate constant for NH4 -> NO2 [1/day]",
            f"{'':12s}{2.000:12.3f}    | BC2 : Rate constant for NO2 -> NO3 [1/day]",
            f"{'':12s}{0.210:12.3f}    | BC3 : Rate constant for org N -> NH4 [1/day]",
            f"{'':12s}{0.350:12.3f}    | BC4 : Rate constant for org P -> diss P [1/day]",
        ]
        swq_path.write_text('\n'.join(swq_lines) + '\n', encoding='utf-8')
        logger.info(f"Routing files written: {rte_path.name}, {swq_path.name}")

    def generate_database_stubs(self) -> None:
        """Generate minimal SWAT database stub files.

        SWAT requires plant.dat, till.dat, pest.dat, fert.dat, and
        urban.dat to be present. These minimal stubs contain a single
        dummy record so that getallo.f can parse them without error.
        Database files only need to exist; the single-HRU lumped model
        uses default parameters.
        """
        # plant.dat (crop database): record format = id, then 4 lines of data
        plant_path = self.pp.txtinout_dir / 'plant.dat'
        plant_lines = [
            "   1",
            "AGRL         WARM SEASON ANNUAL LEGUME",
            "   0.000   0.000   0.000   0.000   0.000   0.000   0.000",
            "   0.000   0.000   0.000   0.000   0.000   0.000   0.000",
            "   0.000   0.000   0.000   0.000   0.000   0.000   0.000",
        ]
        plant_path.write_text('\n'.join(plant_lines) + '\n', encoding='utf-8')

        # till.dat (tillage database): format 6300 = i4
        till_path = self.pp.txtinout_dir / 'till.dat'
        till_path.write_text("   1  Generic tillage\n", encoding='utf-8')

        # pest.dat (pesticide database): format 6200 = i3
        pest_path = self.pp.txtinout_dir / 'pest.dat'
        pest_path.write_text("  1  Generic pesticide\n", encoding='utf-8')

        # fert.dat (fertilizer database): format 6300 = i4
        fert_path = self.pp.txtinout_dir / 'fert.dat'
        fert_path.write_text("   1  Generic fertilizer\n", encoding='utf-8')

        # urban.dat (urban land type database): format 6200 = i3
        urban_path = self.pp.txtinout_dir / 'urban.dat'
        urban_lines = [
            "  1",
            "Urban land type 1",
        ]
        urban_path.write_text('\n'.join(urban_lines) + '\n', encoding='utf-8')

        logger.info(f"Database stub files written to {self.pp.txtinout_dir}")
