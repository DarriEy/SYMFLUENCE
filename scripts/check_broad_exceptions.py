#!/usr/bin/env python3
"""
Fail CI if new broad Exception catches are introduced.

Matches:
  - except Exception:
  - except Exception as e:
  - except (..., Exception, ...):

Comparison is done against a checked-in allowlist so existing technical debt
does not fail CI, while any newly introduced occurrences do.
"""

from __future__ import annotations

import argparse
import sys
import ast
from pathlib import Path


DEFAULT_SCAN_ROOT = Path("src/symfluence")
DEFAULT_ALLOWLIST = Path("tools/quality/broad_exception_allowlist.txt")

def _is_broad_exception(node: ast.expr | None) -> bool:
    """Return True when an except handler catches built-in Exception."""
    if node is None:
        return False

    if isinstance(node, ast.Name):
        return node.id == "Exception"

    if isinstance(node, ast.Attribute):
        return node.attr == "Exception"

    if isinstance(node, ast.Tuple):
        return any(_is_broad_exception(elt) for elt in node.elts)

    return False


def collect_matches(scan_root: Path) -> list[str]:
    """Return normalized match records in form: path:line:source."""
    records: list[str] = []
    py_files = sorted(scan_root.rglob("*.py"))

    for path in py_files:
        rel = path.as_posix()
        try:
            source = path.read_text(encoding="utf-8")
        except OSError as exc:
            print(f"warning: could not read {rel}: {exc}", file=sys.stderr)
            continue

        lines = source.splitlines()

        try:
            tree = ast.parse(source, filename=rel)
        except SyntaxError as exc:
            print(f"warning: could not parse {rel}: {exc}", file=sys.stderr)
            continue

        for node in ast.walk(tree):
            if not isinstance(node, ast.ExceptHandler):
                continue
            if not _is_broad_exception(node.type):
                continue

            lineno = node.lineno
            line = lines[lineno - 1].strip() if 1 <= lineno <= len(lines) else ""
            records.append(f"{rel}:{lineno}:{line}")

    return sorted(records)


def read_allowlist(path: Path) -> list[str]:
    """Read allowlist lines (ignoring comments/blank lines)."""
    if not path.exists():
        return []

    lines = []
    for raw in path.read_text(encoding="utf-8").splitlines():
        text = raw.strip()
        if not text or text.startswith("#"):
            continue
        lines.append(text)
    return sorted(lines)


def write_allowlist(path: Path, records: list[str]) -> None:
    """Write allowlist with a short header and sorted records."""
    path.parent.mkdir(parents=True, exist_ok=True)
    header = [
        "# Broad Exception Catch Allowlist",
        "# Auto-generated by scripts/check_broad_exceptions.py --update",
        "# Format: relative/path.py:line:source",
        "",
    ]
    body = [f"{r}\n" for r in records]
    path.write_text("\n".join(header) + "".join(body), encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--scan-root",
        type=Path,
        default=DEFAULT_SCAN_ROOT,
        help=f"Root directory to scan (default: {DEFAULT_SCAN_ROOT})",
    )
    parser.add_argument(
        "--allowlist",
        type=Path,
        default=DEFAULT_ALLOWLIST,
        help=f"Allowlist path (default: {DEFAULT_ALLOWLIST})",
    )
    parser.add_argument(
        "--update",
        action="store_true",
        help="Regenerate allowlist from current scan",
    )
    args = parser.parse_args()

    current = collect_matches(args.scan_root)

    if args.update:
        write_allowlist(args.allowlist, current)
        print(f"Updated allowlist with {len(current)} entries: {args.allowlist}")
        return 0

    allowed = read_allowlist(args.allowlist)
    allowed_set = set(allowed)
    current_set = set(current)

    new_items = sorted(current_set - allowed_set)
    stale_items = sorted(allowed_set - current_set)

    if new_items:
        print("New broad Exception catches detected (not in allowlist):", file=sys.stderr)
        for item in new_items:
            print(f"  {item}", file=sys.stderr)
        print(
            "\nTo accept intentional changes, run:\n"
            "  python scripts/check_broad_exceptions.py --update",
            file=sys.stderr,
        )
        return 1

    print(f"Broad exception guard passed ({len(current)} allowlisted matches).")
    if stale_items:
        print(
            f"Note: {len(stale_items)} stale allowlist entries detected. "
            "Run --update to prune.",
            file=sys.stderr,
        )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
